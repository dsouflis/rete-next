# Cypher grammar for conditions
## Rationale
Cypher is the query language for graph databases. It was originally invented for Neo4j, but was later opened up with
the [OpenCypher](https://opencypher.org/) project. The grammar I adopted is a subset of the 
[v5 Neo4J flavor of Cypher](https://neo4j.com/docs/getting-started/cypher-intro/). Knowledge graphs are close enough
in structure to property graphs, and Cypher is a de facto standard that is known by many. Moreover, Cypher uses a
pattern-based approach that is more concise than writing individual conditions and tests by hand. 

Another reason for adding this feature is that, not only people know Cypher, but also LLMs. So querying the knowledge
base can, in principle, be done in natural language, via Cypher generated by an LLM.

## MATCH subset that is covered
It is important to note that only a subset of the MATCH syntax is covered. 

- First of all, only fixed-length and non-linear patterns are covered.
- Currently, only node property key-value expressions are supported.
- Only label conjunctions are supported for nodes.
- Only a single label is supported for relations, pending implementation of reified relationships 

## What is planned to be covered
- Label property key-value expressions for relationships. 
 Some way needs to be devised to distinguish direct relations (i.e. 
``(_ rel _)``) that do not have properties and can encode a single label, in usual knowledge graph fashion, vs. reified relations (i.e
``(_ <rel> _) (<rel> <prop> _)``) where properties and multiple labels can be encoded.
- WHERE clauses in node or relationship patterns (simple conditions)
- Standalone WHERE clauses (simple conditions)

## What may be covered in the future
- Variable-length patterns may be covered by pre-processing transitive closures. There is no current plan for covering 
shortest paths.
- More elaborate WHERE clauses, standalone or in node or relationship patterns

## Mapping Cypher to conditions
Variables are shared among all Cypher and non-Cypher conditions in a query or a production. This partly makes up for
not being able to chain multiple node patterns using WHERE clauses.

Let's witness how an artificially contrived Cypher pattern is translated.

```cypher
(k:King {name: "Henry"} where k.age > 400)<--(p:Person&Author&Fisherman)-[:left_of]->(:Person)-->(p)
```
is mapped to 
```
(<k> is-a King)
(<k> name Henry)
(<k> age <_0>)
(<_0> > 400)
(<p> <_1> <k>)
(<p> is-a Person)
(<p> is-a Author)
(<p> is-a Fisherman)
(<p> left_of <_2>)
(<_2> is-a Person)
(<_2> <_3> <p>)
```
Note that non-linearity presents no problem.
